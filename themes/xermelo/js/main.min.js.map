{"version":3,"file":"main.min.js","mappings":"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","sources":["webpack:///./js/components/cne-locator.js","webpack:///./js/main.js"],"sourcesContent":["const settings = {\n    classNames: {\n        container: 'cne-locator',\n        interfaceContainer: 'cne-locator__interface',\n        openCloseButton: 'cne-locator__intro__open-close-button',\n        open: 'cne-locator--open',\n        closing: 'cne-locator--closing',\n        selected: 'cne-locator--selected',\n        hidden: 'cne-locator--hidden',\n    },\n};\n\n/**\n * Drives the \"Meet our Nurses\" widget on the \"Ask a Nurse\n * About XERMELO\" page\n */\nexport default class CneLocator {\n    /**\n     * @constructor\n     * @param {Element} container The element for which to initialize\n     */\n    constructor(container) {\n        /** @type {boolean} */\n        this.isOpen = false;\n\n        /** @type {number} */\n        this.selectedRegionIndex = null;\n\n        // Locate our DOM elements\n        /** @type {Element} */\n        this.container = container;\n\n        /** @type {Element} */\n        this.interfaceContainer = this.container.querySelector(`.${settings.classNames.interfaceContainer}`);\n        if (!this.interfaceContainer) {\n            return;\n        }\n\n        /** @type {Element} */\n        this.openCloseButton = this.container.querySelector(`.${settings.classNames.openCloseButton}`);\n        if (!this.openCloseButton) {\n            return;\n        }\n\n        /** @type {Element} */\n        this.unselectedMapImage = this.container.querySelector('.cne-locator__map img:not(*[data-region])');\n        if (!this.unselectedMapImage) {\n            return;\n        }\n\n        /** @type {Region[]} */\n        this.regions = [];\n\n        // Find all legend buttons and convert to an array\n        let legendButtons = this.container.querySelectorAll('.cne-locator__legend > li[data-region]');\n        legendButtons = Array.from(legendButtons);\n\n        // Find all unique region IDs across the buttons\n        let uniqueRegionIds = legendButtons.map((legendButton) => legendButton.getAttribute('data-region'));\n        uniqueRegionIds = uniqueRegionIds.filter((value, index, self) => {\n            return self.indexOf(value) === index;\n        });\n\n        // Loop through the unique region IDs\n        uniqueRegionIds.forEach((regionId) => {\n            const legendButtonsForRegion = legendButtons\n                .filter((legendButton) => {\n                    return legendButton.getAttribute('data-region') == regionId;\n                });\n\n            const mapButtons = this.container.querySelectorAll(`.cne-locator__map svg *[data-region=\"${regionId}\"]`);\n            if (!mapButtons) {\n                return;\n            }\n\n            const mapImage = this.container.querySelector(`.cne-locator__map img[data-region=\"${regionId}\"]`);\n            if (!mapImage) {\n                return;\n            }\n\n            const resultContent = this.container.querySelector(`.cne-locator__results > div[data-region=\"${regionId}\"]`);\n            if (!resultContent) {\n                return;\n            }\n\n            const regionIndex = this.regions.length;\n            const region = new Region(\n                legendButtonsForRegion,\n                mapButtons,\n                mapImage,\n                resultContent,\n                () => {\n                    selectRegion.call(this, regionIndex);\n                },\n            );\n\n            this.regions.push(region);\n        });\n\n        // Setup open/close button\n        this.openCloseButton.addEventListener(\n            'click',\n            (event) => {\n                event.preventDefault();\n                event.stopPropagation();\n\n                // Toggle open state\n                if (this.isOpen) {\n                    this.closeInterface();\n                } else {\n                    this.openInterface();\n                }\n            },\n        );\n\n        // Setup body click event\n        document.body.addEventListener(\n            'click',\n            (event) => {\n                // Stop if the click occurred within our container\n                if (event.target.closest('*[data-region]')) {\n                    return;\n                }\n\n                selectRegion.call(this, null);\n            },\n        );\n\n        // // Testing\n        // this.openInterface(true);\n    }\n\n    /**\n     * Initializes the CNE locator if the associated element\n     * is found on the DOM\n     */\n    static init() {\n        // Look for elements on the DOM matching our expected\n        // class name\n        const containers = document.getElementsByClassName(\n            settings\n                .classNames\n                .container,\n        );\n\n        for (let i=0; i<containers.length; i++) {\n            new CneLocator(containers[i]);\n        }\n    }\n\n    /**\n     * Opens the map interface\n     * @param {boolean} immediate\n     */\n    openInterface(immediate = false) {\n        // Stop if we're already open\n        if (this.isOpen) {\n            return;\n        }\n\n        this.isOpen = true;\n\n        // Stop any ongoing animation\n        if (this.timeline) {\n            this.timeline.progress(1);\n        }\n\n        // Add \"open\" class\n        this.container\n            .classList\n            .add(settings.classNames.open);\n\n        // Scroll into view, if necessary\n        let scrollDistance = 0;\n        const bounds = this.interfaceContainer.getBoundingClientRect();\n\n        // First check the ISI tray\n        const isiTrayTop = getIsiTrayTop();\n        if (isiTrayTop !== null) {\n            if (bounds.bottom > isiTrayTop) {\n                scrollDistance = bounds.bottom - isiTrayTop;\n            }\n        }\n\n        // Next check the header\n        const headerBottom = getHeaderBottom();\n        if (headerBottom !== null) {\n            const newBoundsTop = bounds.top - scrollDistance;\n            if (newBoundsTop < headerBottom) {\n                // Reduce the amount we're scrolling\n                scrollDistance -= headerBottom - newBoundsTop;\n            }\n        }\n\n        // Scroll if we've decided to do so\n        if (scrollDistance != 0) {\n            const scrollTarget = Math.floor(\n                window.scrollY +\n                scrollDistance,\n            );\n\n            window.scrollTo({\n                left: 0,\n                top: scrollTarget,\n                behavior: 'smooth',\n            });\n        }\n\n        const finishCallback = () => {\n            // Clear timeline variable\n            this.timeline = null;\n\n            // Clear inline styles\n            this.interfaceContainer.removeAttribute('style');\n        };\n\n        if (immediate) {\n            finishCallback();\n\n            // Stop here\n            return;\n        }\n\n        // Animate transition\n        this.timeline = gsap.timeline();\n\n        this.timeline.from(\n            this.interfaceContainer,\n            0.5,\n            {\n                ease: 'power2.out',\n                height: 0,\n            },\n            0,\n        );\n\n        this.timeline.add(finishCallback);\n    }\n\n    /**\n     * Closes the map interface\n     * @param {boolean} immediate\n     */\n    closeInterface(immediate = false) {\n        // Stop if we're already closed\n        if (!this.isOpen) {\n            return;\n        }\n\n        this.isOpen = false;\n\n        // Stop any ongoing animation\n        if (this.timeline) {\n            this.timeline.progress(1);\n        }\n\n        // Add \"closing\" class\n        this.container\n            .classList\n            .add(settings.classNames.closing);\n\n        // Remove \"open\" class\n        this.container\n            .classList\n            .remove(settings.classNames.open);\n\n        const finishCallback = () => {\n            // Clear timeline variable\n            this.timeline = null;\n\n            // Remove \"closing\" class\n            this.container\n                .classList\n                .remove(settings.classNames.closing);\n\n            // Clear inline styles\n            this.interfaceContainer.removeAttribute('style');\n\n            // Deselect any selected region\n            if (this.selectedRegionIndex !== null) {\n                selectRegion.call(this, null);\n            }\n        };\n\n        if (immediate) {\n            finishCallback();\n\n            // Stop here\n            return;\n        }\n\n        // Animate transition\n        this.timeline = gsap.timeline();\n\n        this.timeline.to(\n            this.interfaceContainer,\n            0.5,\n            {\n                ease: 'power2.out',\n                height: 0,\n            },\n            0,\n        );\n\n        this.timeline.add(finishCallback);\n    }\n}\n\n/*\n    Internal methods & classes\n*/\n\n/** Represents a clickable map region and its associated legend button(s) */\nclass Region {\n    /**\n     * @constructor\n     * @param {Element[]} legendButtons\n     * @param {NodeList} mapButtons\n     * @param {Element} mapImage\n     * @param {Element} resultContent\n     * @param {function} selectCallback\n     */\n    constructor(\n        legendButtons,\n        mapButtons,\n        mapImage,\n        resultContent,\n        selectCallback,\n    ) {\n        this.legendButtons = legendButtons;\n        this.mapButtons = mapButtons;\n        this.mapImage = mapImage;\n        this.resultContent = resultContent;\n        this.isSelected = false;\n\n        for (let i=0; i<this.legendButtons.length; i++) {\n            this.legendButtons[i].addEventListener('click', selectCallback);\n        }\n\n        for (let i=0; i<this.mapButtons.length; i++) {\n            this.mapButtons[i].addEventListener('click', selectCallback);\n        }\n    }\n\n    /**\n     * Sets or unsets selected state\n     * @param {boolean} selected\n     */\n    setSelectedState(selected) {\n        if (selected == this.isSelected) {\n            // Do nothing\n            return;\n        }\n\n        // Update state\n        this.isSelected = selected;\n\n        if (this.isSelected) {\n            // Select region\n            for (let i=0; i<this.legendButtons.length; i++) {\n                this.legendButtons[i]\n                    .classList\n                    .add(settings.classNames.selected);\n            }\n\n            for (let i=0; i<this.mapButtons.length; i++) {\n                this.mapButtons[i]\n                    .classList\n                    .add(settings.classNames.selected);\n            }\n\n            this.mapImage\n                .classList\n                .add(settings.classNames.selected);\n\n            this.resultContent\n                .classList\n                .add(settings.classNames.selected);\n        } else {\n            // Deselect region\n            for (let i=0; i<this.legendButtons.length; i++) {\n                this.legendButtons[i]\n                    .classList\n                    .remove(settings.classNames.selected);\n            }\n\n            for (let i=0; i<this.mapButtons.length; i++) {\n                this.mapButtons[i]\n                    .classList\n                    .remove(settings.classNames.selected);\n            }\n\n            this.mapImage\n                .classList\n                .remove(settings.classNames.selected);\n\n            this.resultContent\n                .classList\n                .remove(settings.classNames.selected);\n        }\n    }\n}\n\n/**\n * Switches the currently selected region\n * @this {CneLocator}\n * @param {number} index\n * @param {boolean} immediate\n */\nfunction selectRegion(\n    index,\n    immediate = false,\n) {\n    if (\n        index === this.selectedRegionIndex ||\n        index < 0 ||\n        index >= this.regions.length\n    ) {\n        return;\n    }\n\n    let fromRegion;\n    if (this.selectedRegionIndex !== null) {\n        fromRegion = this.regions[this.selectedRegionIndex];\n    }\n\n    let toRegion;\n    if (index !== null) {\n        toRegion = this.regions[index];\n    }\n\n    // If a region is currently selected, deselect it\n    if (fromRegion) {\n        fromRegion.setSelectedState(false);\n    }\n\n    // If we're navigating to a region, select it\n    if (toRegion) {\n        toRegion.setSelectedState(true);\n\n        // Hide base/unselected map image if visible\n        if (!fromRegion) {\n            this.unselectedMapImage\n                .classList\n                .add(settings.classNames.hidden);\n        }\n\n        // Scroll into view, if necessary\n        let scrollDistance = 0;\n        const bounds = toRegion.resultContent.getBoundingClientRect();\n\n        // First check the ISI tray\n        const isiTrayTop = getIsiTrayTop();\n        if (isiTrayTop !== null) {\n            if (bounds.bottom > isiTrayTop) {\n                scrollDistance = bounds.bottom - isiTrayTop;\n            }\n        }\n\n        // Next check the header\n        const headerBottom = getHeaderBottom();\n        if (headerBottom !== null) {\n            const newBoundsTop = bounds.top - scrollDistance;\n            if (newBoundsTop < headerBottom) {\n                // Reduce the amount we're scrolling\n                scrollDistance -= headerBottom - newBoundsTop;\n            }\n        }\n\n        // Scroll if we've decided to do so\n        if (scrollDistance != 0) {\n            const scrollTarget = Math.floor(\n                window.scrollY +\n                scrollDistance,\n            );\n\n            window.scrollTo({\n                left: 0,\n                top: scrollTarget,\n                behavior: 'smooth',\n            });\n        }\n    } else {\n        // Show base/unselected map image if hidden\n        if (fromRegion) {\n            this.unselectedMapImage\n                .classList\n                .remove(settings.classNames.hidden);\n        }\n    }\n\n    // Update our selected index\n    this.selectedRegionIndex = index;\n}\n\n/**\n * Calculates the top boundary of the current ISI tray - note\n * that we don't leverage the IsiTray class because it's\n * compiled into the TerSera javascript and won't be availble\n * to Xermelo; this isn't the greatest but the scrolling-into-\n * view is kind of a nice-to-have\n * @return {number} The top boundary of the ISI tray, if\n * present and visible, or null\n */\nfunction getIsiTrayTop() {\n    const isiTray = document.getElementById('isi-tray');\n    if (!isiTray) {\n        // Can't find the ISI tray\n        return null;\n    }\n\n    if (!isiTray.classList.contains('isi-tray--visible')) {\n        // ISI tray doesn't appear to be visible\n        return null;\n    }\n\n    // Found it\n    return isiTray.getBoundingClientRect().top;\n}\n\n/**\n * Same as above, but for the sticky header height\n * @return {number} The bottom boundary of the header, if\n * present and sticky, or null\n */\nfunction getHeaderBottom() {\n    const stickyHeader = document.querySelector('.header--sticky .header__fixed-container');\n    if (!stickyHeader) {\n        return null;\n    }\n\n    return stickyHeader.getBoundingClientRect().bottom;\n}\n","// Components\nimport CneLocator from './components/cne-locator';\n\n// Xermelo-specific initialization\nCneLocator.init();\n"],"names":["settings","CneLocator","container","_this","_classCallCheck","this","isOpen","selectedRegionIndex","interfaceContainer","querySelector","concat","openCloseButton","unselectedMapImage","regions","legendButtons","querySelectorAll","uniqueRegionIds","Array","from","map","legendButton","getAttribute","filter","value","index","self","indexOf","forEach","regionId","legendButtonsForRegion","mapButtons","mapImage","resultContent","regionIndex","length","region","Region","selectRegion","call","push","addEventListener","event","preventDefault","stopPropagation","closeInterface","openInterface","document","body","target","closest","_createClass","key","_this2","immediate","arguments","undefined","timeline","progress","classList","add","scrollDistance","bounds","getBoundingClientRect","isiTrayTop","getIsiTrayTop","bottom","headerBottom","getHeaderBottom","newBoundsTop","top","scrollTarget","Math","floor","window","scrollY","scrollTo","left","behavior","finishCallback","removeAttribute","gsap","ease","height","_this3","remove","to","containers","getElementsByClassName","i","selectCallback","isSelected","selected","fromRegion","toRegion","setSelectedState","isiTray","getElementById","contains","stickyHeader","init"],"sourceRoot":""}